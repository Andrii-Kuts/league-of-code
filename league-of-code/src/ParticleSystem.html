<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle System</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    #hero-container {
      position: relative;
      width: 100%;
      height: 100%;
    }
    
    #hero-canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="hero-container">
    <canvas id="hero-canvas"></canvas>
  </div>

  <script>
    const NODE_SIZE = 4;
    const LINE_COLOR = "rgba(240,240,240,1)";
    const NODES_DISTANCE = 35;
    const SPEED_DAMPING = 0.8;

    // Course color configurations
    const courseColorConfigs = {
      blue: { particles: ['rgba(59,130,246,', 'rgba(96,165,250,', 'rgba(147,197,253,'] },
      green: { particles: ['rgba(34,197,94,', 'rgba(74,222,128,', 'rgba(134,239,172,'] },
      orange: { particles: ['rgba(249,115,22,', 'rgba(251,146,60,', 'rgba(253,186,116,'] },
      purple: { particles: ['rgba(168,85,247,', 'rgba(192,132,252,', 'rgba(216,180,254,'] },
      pink: { particles: ['rgba(236,72,153,', 'rgba(244,114,182,', 'rgba(249,168,212,'] },
      cyan: { particles: ['rgba(6,182,212,', 'rgba(34,211,238,', 'rgba(103,232,249,'] }
    };

    const courseColorMap = {
      python1: 'blue',
      python2: 'green',
      math101: 'orange',
      datascience: 'purple',
      webdev: 'pink',
      algorithms: 'cyan',
    };

    // Sample course progress data
    const courseProgress = {
      python1: 8,
      python2: 6,
      math101: 5,
      datascience: 7,
      webdev: 4,
      algorithms: 3
    };

    class Particle {
      constructor(x, y, size, colorPrefix, opacity, parent, group) {
        this.x = x;
        this.y = y;
        this.parent = parent;
        this.hasParent = parent !== -1;
        this.parentX = 0;
        this.parentY = 0;
        this.parentSize = 0;
        this.baseSize = size;
        this.opacity = opacity;
        this.colorPrefix = colorPrefix;
        this.size = this.baseSize;
        this.timeOffset = Math.random() * Math.PI * 2;
        this.velocityX = 0;
        this.velocityY = 0;
        this.group = group;
        this.pulse = 1;
      }
      
      update(time, parentX, parentY, parentSize) {
        this.pulse = Math.sin(time * 0.01 + this.timeOffset);
        this.size = this.baseSize * (1 + this.pulse * 0.1);
        this.velocityX *= SPEED_DAMPING;
        this.velocityY *= SPEED_DAMPING;
        this.x += this.velocityX;
        this.y += this.velocityY;
        this.parentX = parentX;
        this.parentY = parentY;
        this.parentSize = parentSize;
      }
      
      draw(ctx) {
        this.drawCircle(ctx);
      }

      drawCircle(ctx) {
        ctx.fillStyle = this.colorPrefix + this.opacity.toFixed(2) + ')';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }

      drawEdge(ctx, particle) {
        if (particle === null) return;
        ctx.strokeStyle = LINE_COLOR;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(particle.x, particle.y);
        ctx.closePath();
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    class ParticleSystem {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d', { alpha: true });
        this.particles = [];
        this.animationFrame = null;
        this.time = 0;
        this.mouse = { x: -1000, y: -1000 };
        this.mouseClick = false;
        this.scale = 1;
        
        this.init();
      }

      init() {
        this.ctx.globalCompositeOperation = 'source-over';
        this.setupEventListeners();
        this.resize();
        this.animate();
      }

      setupEventListeners() {
        window.addEventListener('mousemove', (e) => {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          
          if (x >= 0 && x <= rect.width && y >= 0 && y <= rect.height) {
            this.mouse.x = x;
            this.mouse.y = y;
          } else {
            this.mouse.x = -1000;
            this.mouse.y = -1000;
          }
        });

        window.addEventListener('mousedown', () => {
          this.mouseClick = true;
        });

        let resizeTimeout;
        window.addEventListener('resize', () => {
          if (resizeTimeout) clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(() => this.resize(), 150);
        }, { passive: true });
      }

      resize() {
        const container = this.canvas.parentElement;
        if (!container) return;
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        this.canvas.width = width;
        this.canvas.height = height;
        
        this.createParticles(width, height);
      }

      scaleCoefficient(nodesCount) {
        if (nodesCount === 0) return 1.0;
        return Math.min(1, 12 / Math.sqrt(nodesCount));
      }

      createParticles(width, height) {
        const centerX = width / 2;
        const centerY = height / 2;
        const particles = [];

        const nonEmptyCourses = Object.entries(courseProgress)
          .filter(([_, progress]) => progress > 0);

        let nodesCount = nonEmptyCourses.reduce((sum, [_, progress]) => sum + progress, 0);
        const fakeNodesCount = Math.max(0, 100 - nodesCount);
        nodesCount += fakeNodesCount;
        this.scale = this.scaleCoefficient(nodesCount);

        nonEmptyCourses.forEach(([courseId, progress], index) => {
          if (progress === 0) return;

          // Create course particle (center)
          const colorKey = courseColorMap[courseId];
          const config = courseColorConfigs[colorKey];
          const colorPrefix = config.particles[Math.floor(Math.random() * config.particles.length)];
          const angle = Math.random() * Math.PI * 2;
          const dist = Math.random() * 30;
          const x = centerX + Math.cos(angle) * dist;
          const y = centerY + Math.sin(angle) * dist;
          const courseParticle = new Particle(x, y, 3 * NODE_SIZE * this.scale, colorPrefix, 1, -1, index);
          particles.push(courseParticle);
          const courseParticleIndex = particles.length - 1;
          
          // Create progress particles
          for (let i = 0; i < progress; i++) {
            const colorKey = courseColorMap[courseId];
            const config = courseColorConfigs[colorKey];
            const colorPrefix = config.particles[Math.floor(Math.random() * config.particles.length)];
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 100;
            const x = courseParticle.x + Math.cos(angle) * distance;
            const y = courseParticle.y + Math.sin(angle) * distance;
            const particle = new Particle(x, y, NODE_SIZE * this.scale, colorPrefix, 1, courseParticleIndex, index);
            particles.push(particle);
          }
        });

        // Create fake particles
        for (let i = 0; i < fakeNodesCount; i++) {
          const colorPrefix = "rgba(230,230,230,";
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * 100;
          const x = centerX / 2 + Math.cos(angle) * distance;
          const y = centerY / 2 + Math.sin(angle) * distance;
          const particle = new Particle(x, y, NODE_SIZE * this.scale, colorPrefix, 1, -1, -1 - Math.floor(Math.random() * 3));
          particles.push(particle);
        }
        
        this.particles = particles;
      }

      animate() {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        this.time += 1;
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        if (width === 0 || height === 0) {
          this.animationFrame = requestAnimationFrame(() => this.animate());
          return;
        }

        this.ctx.clearRect(0, 0, width, height);
        
        const particles = this.particles;
        const mouse = this.mouse;
        let repulsionForce = 3;
        let repulsionRadius = 80;
        
        if (this.mouseClick) {
          repulsionRadius = 160;
          repulsionForce = 40;
          this.mouseClick = false;
        }

        const basePadding = NODES_DISTANCE * this.scale;
        const gridSize = NODE_SIZE * 6 * this.scale + basePadding * 3;
        const gridSizeInv = 1 / gridSize;
        const grid = new Map();

        const posHash = (x, y) => x * 1e9 + y;

        // Build spatial grid
        particles.forEach((particle, index) => {
          const gridX = Math.floor(particle.x * gridSizeInv);
          const gridY = Math.floor(particle.y * gridSizeInv);
          const pos = posHash(gridX, gridY);
          if (!grid.has(pos)) {
            grid.set(pos, [index]);
          } else {
            grid.get(pos).push(index);
          }
        });

        // Update particles
        for (let i = 0; i < particles.length; i++) {
          const particle = particles[i];
          let fx = 0;
          let fy = 0;
          
          // Attraction to center
          const attractionCoefficient = 0.0005;
          const targetX = centerX;
          const targetY = centerY;
          fx += attractionCoefficient * (targetX - particle.x);
          fy += attractionCoefficient * (targetY - particle.y);
          
          // Mouse repulsion
          const mouseDistance2 = (mouse.x - particle.x) ** 2 + (mouse.y - particle.y) ** 2;
          const mouseDistance = Math.sqrt(mouseDistance2);
          if (mouseDistance < repulsionRadius) {
            const force = repulsionForce * (repulsionRadius - mouseDistance) / repulsionRadius;
            fx += (particle.x - mouse.x) / mouseDistance * force;
            fy += (particle.y - mouse.y) / mouseDistance * force;
          }
          
          let drawCnt = 0;
          const gridX = Math.floor(particle.x * gridSizeInv);
          const gridY = Math.floor(particle.y * gridSizeInv);
          
          // Check neighboring grid cells
          for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
              const pos = posHash(gridX + dx, gridY + dy);
              if (!grid.has(pos)) continue;
              
              grid.get(pos).forEach(j => {
                if (i === j) return;
                
                const particle2 = particles[j];
                const dist2 = (particle.x - particle2.x) ** 2 + (particle.y - particle2.y) ** 2;
                const sameGroup = particle.group === particle2.group;
                const padding = basePadding * (sameGroup ? 1 : 3);
                let wantedDistance = padding + particle.size + particle2.size;
                
                // Repulsion between particles
                if (dist2 < wantedDistance ** 2) {
                  const dist = Math.sqrt(dist2);
                  const t = (wantedDistance - dist) / wantedDistance;
                  const force = 6 * t;
                  const relativeForce = (force * particle2.size) / (particle.size + particle2.size);
                  fx += (particle.x - particle2.x) / dist * relativeForce;
                  fy += (particle.y - particle2.y) / dist * relativeForce;
                }
                
                // Draw edges between same group particles
                if (sameGroup && drawCnt < 5 && dist2 < (wantedDistance + 1) ** 2) {
                  particle.drawEdge(this.ctx, particle2);
                  drawCnt++;
                }
              });
            }
          }
          
          particle.velocityX += fx;
          particle.velocityY += fy;
        }
        
        // Update particle positions
        particles.forEach(particle => {
          const parent = particle.parent === -1 ? null : particles[particle.parent];
          const parentX = parent ? parent.x : 0;
          const parentY = parent ? parent.y : 0;
          const parentSize = parent ? parent.size : 0;
          particle.update(this.time, parentX, parentY, parentSize);
        });
        
        // Draw particles
        particles.forEach(particle => particle.draw(this.ctx));
        
        this.animationFrame = requestAnimationFrame(() => this.animate());
      }
    }

    // Initialize the particle system when the page loads
    window.addEventListener('DOMContentLoaded', () => {
      new ParticleSystem('hero-canvas');
    });
  </script>
</body>
</html>